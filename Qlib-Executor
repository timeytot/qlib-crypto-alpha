
Qlib Executor Infrastructure Data Structure Diagram (Nested Backtesting Scenario)Below is a complete data structure relationship diagram based on the execution process of BaseExecutor.reset_common_infra(), illustrating the object reference relationships for the top-level (daily frequency) and inner-level (minute frequency) Executors after initialization and reset.
    
    Global Shared Resources
    └── common_infra_global (CommonInfrastructure object)
        ├── trade_account → Account(init_cash=100000)   ← Shared by all levels (same instance)
        └── trade_exchange → Exchange(...)              ← Shared by all levels (same instance)
    
    Top-Level Executor (NestedExecutor, daily frequency)
    ├── self.common_infra ───────────────────────────► common_infra_global   (direct reference)
    ├── self.level_infra (LevelInfrastructure)
    │   ├── common_infra ───────────────────────────► common_infra_global
    │   ├── executor ───────────────────────────────► Top-level NestedExecutor itself
    │   ├── trade_calendar → Daily TradeCalendarManager (e.g., 2025-01-02 ~ 2025-01-10)
    │   └── sub_level_infra ───────────────────────► Inner-level level_infra (below)
    │
    ├── self.inner_executor → Inner SimulatorExecutor (30-minute frequency)
    │   ├── self.common_infra ──────────────────────► common_infra_global   (reference or updated to same object)
    │   ├── self.level_infra (LevelInfrastructure)
    │   │   ├── common_infra ───────────────────────► common_infra_global
    │   │   ├── executor ───────────────────────────► Inner SimulatorExecutor itself
    │   │   └── trade_calendar → 30-minute TradeCalendarManager
    │   │       (reset to the current day's 30-minute interval on each outer step)
    │   │
    │   └── self.trade_account → Same Account object (shared via copy or direct reference)
    │
    └── self.inner_strategy
        └── Accesses inner_executor's trade_calendar, common_infra, etc., via level_infra


start_idx, end_idx = get_start_end_idx(sub_cal, trade_decision)   https://github.com/microsoft/qlib/blob/main/qlib/backtest/executor.py#L432

    Outer-level Decision (daily frequency)
    └── Contains trade_range = TradeRangeByTime("09:30", "14:30")
        └── self.start_time = time(9, 30, 0)      ← User-defined fixed daily start time (hours/minutes only)
            self.end_time   = time(14, 30, 0)     ← User-defined fixed daily end time
    
    NestedExecutor starts inner loop
    └── Calls get_start_end_idx(sub_cal, outer_decision)
        └── sub_cal is the inner_calendar (inner-level TradeCalendarManager)
    
    get_start_end_idx calls
    └── outer_decision.get_range_limit(inner_calendar=inner_calendar)
    
    _get_range_limit calls
    └── self.trade_range(inner_calendar)   ← Executes TradeRangeByTime.__call__
    
    TradeRangeByTime.__call__ executes the key three lines:
    1. start_date = trade_calendar.start_time.date()
       → Extracts the current loop's date from inner_calendar (e.g., 2025-01-02)
    
    2. val_start = concat_date_time(start_date, self.start_time)
       → Combines "today's date" + "user-defined daily start time" into a full timestamp
       → 2025-01-02 09:30:00
    
       val_end   = concat_date_time(start_date, self.end_time)
       → 2025-01-02 14:30:00
    
    3. return trade_calendar.get_range_idx(val_start, val_end)
       → Looks up the step indices corresponding to 09:30 and 14:30 in the inner_calendar sequence
       → Returns (start_idx, end_idx), e.g., (19, 29)

    Why must inner_calendar be passed?Because:TradeRangeByTime only stores hours and minutes (09:30, 14:30) — it has no knowledge of which actual date it is.
    Only inner_calendar.start_time knows whether the current loop is processing 2025-01-02 or 2025-01-03.
    Different dates produce different full timestamps, resulting in different indices.
    
    One-sentence Summary (you nailed it!)Yes — it uses the date from inner_calendar (trade_calendar.start_time.date()) to determine "which day today is", then combines it with the user-preset self.start_time / self.end_time (fixed daily hours/minutes) from TradeRangeByTime to form complete datetimes, which are finally converted into step indices for the inner executor. This precisely controls which high-frequency bars are allowed to trade on any given day.This design is extremely elegant: the user only needs to set the window once ("every day from 09:30 to 14:30"), and the framework automatically adapts it to every specific date and inner-level frequency.




Start_time and end_time of TradeRangeByTime initialized:
    Where start_time and end_time of TradeRangeByTime are initialized,And how, through the call chain, they ultimately map to start_idx, end_idx = get_start_end_idx(...).
    
    user create TradeRangeByTime("09:30", "14:30")
        ↓ (initialization self.start_time / self.end_time)
    TradeDecisionWO(trade_range=trade_range)
        ↓ (The outer decision is passed to NestedExecutor)
    NestedExecutor._collect_data
        ↓
    get_start_end_idx(sub_cal, outer_decision)
        ↓
    outer_decision.get_range_limit(inner_calendar=sub_cal)
        ↓
    outer_decision.trade_range(sub_cal)   ←  TradeRangeByTime.__call__
        ↓
    trade_calendar.get_range_idx("2025-01-02 09:30", "2025-01-02 14:30")
        ↓
    return (start_idx, end_idx)   #  (19, 29)
    
    from qlib.backtest.decision import TradeRangeByTime, TradeDecisionWO, Order
    from qlib.constant import OrderDir
    
    
    trade_range = TradeRangeByTime(
        start_time="09:30",   
        end_time="14:30"     
    )
    
    #   self.start_time = time(9, 30, 0)
    #   self.end_time   = time(14, 30, 0)
    
    
    outer_decision = TradeDecisionWO(
        order_list=[
            Order(
                stock_id="SH600000",
                amount=10000,
                direction=OrderDir.BUY,
            )
        ],
        strategy=outer_strategy,      
        trade_range=trade_range        
    )
    
    from qlib.backtest.utils import get_start_end_idx
    
    while not self.inner_executor.finished():
    
        sub_cal = self.inner_executor.trade_calendar
    
        start_idx, end_idx = get_start_end_idx(sub_cal, trade_decision)
    
        if not self._align_range_limit or start_idx <= sub_cal.get_trade_step() <= end_idx:
            ...
    else:
        sub_cal.step()
