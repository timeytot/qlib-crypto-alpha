Where start_time and end_time of TradeRangeByTime are initialized,And how, through the call chain, they ultimately map to start_idx, end_idx = get_start_end_idx(...).

user create TradeRangeByTime("09:30", "14:30")
    ↓ (initialization self.start_time / self.end_time)
TradeDecisionWO(trade_range=trade_range)
    ↓ (The outer decision is passed to NestedExecutor)
NestedExecutor._collect_data
    ↓
get_start_end_idx(sub_cal, outer_decision)
    ↓
outer_decision.get_range_limit(inner_calendar=sub_cal)
    ↓
outer_decision.trade_range(sub_cal)   ←  TradeRangeByTime.__call__
    ↓
trade_calendar.get_range_idx("2025-01-02 09:30", "2025-01-02 14:30")
    ↓
return (start_idx, end_idx)   #  (19, 29)

from qlib.backtest.decision import TradeRangeByTime, TradeDecisionWO, Order
from qlib.constant import OrderDir


trade_range = TradeRangeByTime(
    start_time="09:30",   
    end_time="14:30"     
)

#   self.start_time = time(9, 30, 0)
#   self.end_time   = time(14, 30, 0)


outer_decision = TradeDecisionWO(
    order_list=[
        Order(
            stock_id="SH600000",
            amount=10000,
            direction=OrderDir.BUY,
        )
    ],
    strategy=outer_strategy,      
    trade_range=trade_range        
)

from qlib.backtest.utils import get_start_end_idx

while not self.inner_executor.finished():

    sub_cal = self.inner_executor.trade_calendar

    start_idx, end_idx = get_start_end_idx(sub_cal, trade_decision)

    if not self._align_range_limit or start_idx <= sub_cal.get_trade_step() <= end_idx:
        ...
    else:
        sub_cal.step()
